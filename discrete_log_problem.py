'''Considerar la curva y 2=x 3+905x+100 definida sobre el cuerpo primo de orden 1021 y el punto generador (1006,416). 
Desarrollar alguna estrategia que permita resolver el problema del logaritmo discreto kP=(612,827)'''

from finite_field_element import FiniteFieldElement
from elliptic_curve_point import EllipticCurvePoint
from timeit import default_timer as timer

def brute_force(generator, order, result):
    start = timer()
    for i in range(1, order):
        if i * generator == result:
            end = timer()
            print(f"Time elapsed: {end - start}")
            return i
    
def baby_steps_giant_steps(r, s, generator, order, result):
    start = timer()
    if (r * s <= order):
        print(f"r * s must be greater than {order}")
        return -1
    baby_steps = {} # Diccionario donde las claves son strings del formato (x, y) mod p y los valores son la iteracion en la que se obtuvo ese punto
    for i in range(1, r):
        point = i* generator
        if point == result: # La clave buscada estaba entre 1 y r
            end = timer()
            print(f"Time elapsed: {end - start}")
            return i
        baby_steps[point.print_info()] = i
    for j in range(1, s):
        substracting_point = (j * r) * generator
        # Para restar un punto de curva eliptica, realizo una suma de ese punto pero invirtiendo el valor de y
        point = result + EllipticCurvePoint(substracting_point.x, -1 * substracting_point.y, substracting_point.a, substracting_point.b) 
        if point.print_info() in baby_steps: # Si hay una colision, es decir, calcule un punto que ya calcule en los baby steps
            solution = baby_steps[point.print_info()] + j * r
            end = timer()
            print(f"Time elapsed: {end - start}")
            return solution

def main():
    p = 1021
    a = FiniteFieldElement(905, p)
    b = FiniteFieldElement(100, p)
    x = FiniteFieldElement(1006, p)
    y = FiniteFieldElement(416, p)
    generator = EllipticCurvePoint(x, y, a, b)

    curve_size = generator.get_curve_size(p)
    print(f"The curve has {curve_size} points")
    subgroup, order = generator.get_subgroup()
    print(f"The subgroup generated by the point {generator.print_info()} has order {order}")
    print(f"Cofactor: {curve_size}/{order} = {curve_size / order}")

    x_result = FiniteFieldElement(612, p)
    y_result = FiniteFieldElement(827, p)
    result = EllipticCurvePoint(x_result, y_result, a, b)

    #Primero resuelvo por fuerza bruta para compararlo con un algoritmo mejor
    print("Solving with brute force")
    private_key = brute_force(generator, order, result)
    print(f"Obtained result: {private_key}")

    print("Solving with baby steps giant steps")
    private_key = baby_steps_giant_steps(35, 35, generator, order, result)
    print(f"Obtained result: {private_key}")
    
    return

if __name__ == "__main__":
    main()