'''Implementar un esquema básico de acuerdo de clave de Diffie-Hellman usando curvas elípticas.
Usar la curva con p=43, y 2=x 3+6 y como generador g=(13,15). ¿Qué sucede si se emplea el punto g=(9,2)?'''

from elliptic_curve_point import EllipticCurvePoint
from finite_field_element import FiniteFieldElement
import random

class DiffieHellmanPeer:
    def __init__(self, generator, private_key):
        self.generator = generator
        self.__private_key = private_key
        self.public_key = private_key * self.generator
        self.peer_public_key = None
        self.shared_key = None
    
    def send_key(self, peer):
        peer.peer_public_key = self.public_key

    def calculate_shared_key(self):
        shared_key = self.__private_key * self.peer_public_key
        self.shared_key = shared_key

    def change_private_key(self, value):
        self.__private_key = value
        self.public_key = value * self.generator

def main():
    p = 43
    a = FiniteFieldElement(0, p)
    b = FiniteFieldElement(6, p)
    x = FiniteFieldElement(13, p)
    y = FiniteFieldElement(15, p)
    generator = EllipticCurvePoint(x, y, a, b)
    curve_size = generator.get_curve_size(p)
    print(f"The curve has {curve_size} points")
    subgroup, order = generator.get_subgroup()
    print(f"The subgroup generated by the point {generator.print_info()} has order {order}")
    print(f"Cofactor: {curve_size}/{order} = {curve_size / order}") #El cofactor es 3, un valor bastante malo por lo que se debería usar otro generador 

    alice = DiffieHellmanPeer(generator, random.randint(1, order - 1))
    bob = DiffieHellmanPeer(generator, random.randint(1, order - 1))

    alice.send_key(bob)
    bob.send_key(alice)

    alice.calculate_shared_key()
    bob.calculate_shared_key()

    print(f"Shared key computed by Alice: {alice.shared_key.print_info()}")
    print(f"Shared key computed by Bob: {bob.shared_key.print_info()}")

    print('\n')

    x = FiniteFieldElement(9, p)
    y = FiniteFieldElement(2, p)
    generator = EllipticCurvePoint(x, y, a, b)
    subgroup, order = generator.get_subgroup()
    print(f"The subgroup generated by the point {generator.print_info()} has order {order}")
    print(f"Cofactor: {curve_size}/{order} = {curve_size / order}") #El cofactor es 1, es decir, el mejor posible.

    alice = DiffieHellmanPeer(generator, 13)
    bob = DiffieHellmanPeer(generator, 3)

    alice.send_key(bob)
    bob.send_key(alice)

    alice.calculate_shared_key()
    bob.calculate_shared_key()

    # Se puede dar el caso de que la clave privada de Alice multiplicada por la clave privada de Bob sea igual a p, en ese caso
    # la clave compartida calculada es el punto en el infinito y no sirve, por lo que hay que cambiar una de las claves privadas y volver a computar
    while alice.shared_key == EllipticCurvePoint(None, None, a, b): 
        print("Error: The computed shared key is the point at infinity. Please choose a different private key.")
        alice.change_private_key(random.randint(1, order - 1))
        alice.send_key(bob)
        alice.calculate_shared_key()
        bob.calculate_shared_key()

    print(f"Shared key computed by Alice: {alice.shared_key.print_info()}")
    print(f"Shared key computed by Bob: {bob.shared_key.print_info()}")

if __name__ == "__main__":
    main()